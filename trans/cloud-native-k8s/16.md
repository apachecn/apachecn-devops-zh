# 十六、答案

# 第 1 章–与Kubernetes沟通

1.  容器编排是一种软件模式，其中控制和调度多个容器来服务于一个应用。
2.  Kubernetes API 服务器(`kube-apiserver`)处理更新 Kubernetes 资源的请求。调度器(`kube-scheduler`)决定放置(调度)容器的位置。控制器管理器(`kube-controller-manager`)确保集群中反映了 Kubernetes 资源的所需配置。`etcd`为集群配置提供数据存储。
3.  `kube-apiserver`必须从`--authorization-mode=ABAC`和`--authorization-policy-file=filename`参数开始。
4.  为了控制平面的高可用性，在一个主节点发生故障的情况下。
5.  如果已经创建了资源，`kubectl create`将失败，因为该资源已经存在，而`kubectl apply`将尝试对该资源应用任何 YAML 更改。
6.  `kubectl use-context`命令可用于在`kubeconfig`文件内的多个上下文之间切换。要在`kubeconfig`文件之间更改，`KUBECONFIG`环境变量可以设置为新文件的路径。
7.  命令不提供资源更改的历史记录。

# 第 2 章–设置您的 Kubernetes 集群

1.  Minikube 使建立本地 Kubernetes 集群进行开发变得很容易。
2.  在某些情况下，群集的最小固定成本可能大于自行调配的群集。除了计算成本之外，一些受管选项还有许可证成本。
3.  Kubeadm 对基础设施提供商是不可知的，而 Kops 只支持几个具有更深入集成和计算供应的主要提供商。
4.  截至本书撰写之时，AWS、谷歌云平台、数字海洋、VMware 和 OpenStack 处于不同的生产准备水平。
5.  通常，集群组件在`systemd`服务定义中定义，如果节点关闭并在操作系统级别重新启动，该定义允许自动重新启动服务。

# 第 3 章–在 Kubernetes 上运行应用容器

1.  如果您有开发、试运行和生产环境，您可以为每个环境创建一个名称空间。
2.  Pod 运行所在的节点可能处于*断开*状态，控制平面无法到达该节点。通常，当一个节点优雅地退出集群时，Pod 将被简单地重新调度，而不是显示一个*未知的*状态。
3.  防止内存不足的 Pods 接管整个节点并导致节点上其他 Pods 的不确定行为。
4.  如果有*启动*探头，应该增加更多的延迟。如果没有，您需要添加一个，或者给*准备状态*探头添加一个延迟。

# 第 4 章–扩展和部署应用

1.  复制控制器在选择器的配置上没有那么大的灵活性，只允许使用键值选择器。
2.  部署允许您指定如何推出更新。
3.  作业适用于批处理任务，或者可以水平扩展并有明确完成目标的任务。
4.  状态集合提供了一个序数 Pod 标识，当这些 Pod 重新启动时，该标识保持不变。
5.  除了现有版本之外，还可以使用加那利版本创建新的部署。然后，两个版本可以并行访问。

# 第 5 章–服务和入口–与外部世界通信

1.  您将使用集群 IP 服务。
2.  您可以使用`kubectl describe`命令查看节点端口服务在节点上的哪个端口上处于活动状态。
3.  在云环境中，您通常必须为每个负载平衡器付费，入口允许您指定多个路由规则，同时只需为一个负载平衡器付费。
4.  ExternalName 服务可用于轻松路由到云环境中的其他基础架构，如托管数据库和对象存储。

# 第 6 章–Kubernetes 应用配置

1.  机密在`etcd`中被存储编码并可选地加密。配置映射以纯文本存储。
2.  它们是 Base64 编码的。
3.  在描述配置映射时，数据将更加可见。当将配置映射作为环境变量挂载时，键值模式也更容易使用。
4.  根据您如何设置集群，您的机密可能根本不会加密。如果没有设置群集的加密配置，机密将只进行 Base64 编码，并且很容易解码。通过使用加密配置创建您的集群，您的机密将被加密存储在`etcd`中。这不是安全灵丹妙药，但静态加密对于提高机密的安全性肯定是必要的。

# 第 7 章–Kubernetes的存储

1.  卷与 Pod 的生命周期相关联，并在删除 Pod 时被删除。永久卷将一直保留，直到集群被删除，或者它们自己被明确删除。
2.  存储评估定义持久卷的*类型*。它们可用于区分不同类型的存储，例如更快的固态硬盘存储和更慢的硬盘存储，或者不同类型的云存储。存储评估确定持久卷声明和持久卷将去往何处获取已调配的存储。
3.  使用集成存储资源调配的托管 Kubernetes 服务，或向集群添加**云控制器管理器**配置。
4.  任何需要将状态存储到超过单个 Pod 寿命的应用都不能与 Volumes 一起工作。任何需要具有能够容忍 Pod 故障的状态的应用都需要一个持久卷。

# 第 8 章–Pod 放置控制

1.  节点选择器可用于匹配节点标签，多个节点可满足要求。使用节点名称意味着指定必须放置 Pod 的单个节点。
2.  Kubernetes 实现了一些默认的污点，以确保 Pods 不会在出现故障或缺乏资源的节点上进行调度。此外，Kubernetes 污染主节点，以防止在主节点上调度用户应用。
3.  过多的亲缘关系和反亲缘关系可能会降低调度程序的速度或导致其无响应。在具有大量亲和力或反亲和力的情况下，确定 Pod 的位置是非常费计算的。
4.  使用反关联性，您可以防止 Pods 与相同故障域中的同类 Pods 共存。同一故障域中的节点将被标记为故障域或区域标识符。反关联性会在同一个故障域中寻找匹配特定应用层的 Pods，并阻止在匹配该域的节点上进行调度。最终结果将是三层应用的每一层分布在多个故障域中。

# 第 9 章–Kubernetes的可观测性

1.  指标对应于跨许多类别(包括磁盘、中央处理器、内存、延迟等)呈现应用/计算性能和/或使用情况的数值。日志对应于应用、节点或控制平面文本日志。
2.  格拉夫纳用户界面是高度可定制的，可以用来以优雅、灵活的方式呈现复杂的普罗米修斯(或另一个数据源)查询。
3.  FluentD 需要在生产集群上运行，以便收集日志。Elasticsearch 和 Kibana 可以在单独的集群或其他基础设施上运行。

# 第 10 章–Kubernetes故障排除

1.  Kubernetes 的优势之一是能够通过添加节点或使用污染和容忍等控制来更改 Pod 的位置，从而轻松扩展集群。此外，Pod 重启会导致同一应用的 IP 完全不同。这意味着计算和网络拓扑都可以不断变化。
2.  `kubelet`通常作为带有`systemd`的 Linux 服务运行，使用`systemctl`进行控制并登录`journalctl`。
3.  有几种不同的方法可以使用，但是一般来说，您需要检查是否所有节点都准备好了并且可以调度；是否有任何Pod 放置控制排除Pod 的调度；以及是否有任何不存在的相关存储、配置映射或机密。

# 第 11 章–Kubernetes 上的模板代码生成和 CI/CD

1.  Helm Charts 使用模板和变量，而 Kustomize 使用基于补丁的策略。Kustomize 内置于 kubectl 的最新版本中，而 Helm 使用一个单独的 CLI 工具。
2.  配置应该强调安全性，因为部署凭据可用于将攻击者工作负载部署到您的集群。在云提供商上使用安全环境变量或访问管理控制是两个好策略。凭证绝对不应该放在任何 Git 存储库中。
3.  集群内设置可能更可取，因为Kubernetes凭证不需要由外部系统提供。集群外设置通常比集群内设置更简单、更同步，集群内设置由控制环路决定何时更改资源配置。

# 第 12 章–Kubernetes安全和合规

1.  MutatingAdmissionWebhook 和 ValidatingAdmissionWebhook。
2.  带有空白窗格选择器的网络策略具有选择所有窗格的效果。选择了所有端口的网络策略，并且添加了没有任何规则的入口和出口类型，将具有自动拒绝网络策略命名空间中所有端口的所有入口和出口的效果。
3.  我们希望跟踪任何修补或更新资源的应用编程接口请求，因为攻击者可以用恶意容器更新部署、Pod 或其他资源。

# 第 13 章–用 CRDs 扩展 Kubernetes

1.  存储的版本是实际存储在数据存储中的版本。服务版本是指被应用编程接口接受用于读或写操作的任何版本。服务版本存储在`etcd`时转换为存储版本。
2.  测量、分析和更新(通常)。
3.  根据云提供商的不同，**集群自动缩放器**插件将直接更新自动缩放组，以便添加或删除节点。

# 第 14 章–服务网格和无服务器

1.  静态特使配置是指由用户手动创建或编写的特使配置。动态特使配置(像 Istio 提供的配置)将不断适应新容器，以及来自外部控制器或数据平面的新路由和过滤规则。
2.  侦听器、路由、集群和端点。
3.  Knative 需要许多组件才能运行。这允许大量定制，但比 OpenFaaS 更难设置和操作。

# 第 15 章–Kubernetes 上的有状态工作负载

1.  Minio 是一款与 AWS S3 兼容的存储工具。
2.  除了持久卷稳定性之外，状态集还通过提供稳定、有序的 Pod 标识来帮助自集群应用，如分布式数据库。
3.  在 Kubernetes 中，Pods 可以是短暂的，有状态的应用可以是分布式的。这意味着，如果 Pods 改变身份，存储需要从头开始复制，那么维护 Pods 之间状态的过程(例如，数据库共识)可能会变得困难。